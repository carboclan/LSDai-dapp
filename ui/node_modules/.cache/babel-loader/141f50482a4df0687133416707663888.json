{"ast":null,"code":"\"use strict\";\n\nvar __values = this && this.__values || function (o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n      i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ethUtil = require(\"ethereumjs-util\");\n\nvar DEFAULT_ADDRESS_SEARCH_LIMIT = 1000;\n\nvar DerivedHDKeyInfoIterator =\n/** @class */\nfunction () {\n  function DerivedHDKeyInfoIterator(initialDerivedKey, searchLimit) {\n    if (searchLimit === void 0) {\n      searchLimit = DEFAULT_ADDRESS_SEARCH_LIMIT;\n    }\n\n    this._searchLimit = searchLimit;\n    this._parentDerivedKeyInfo = initialDerivedKey;\n    this._index = 0;\n  }\n\n  DerivedHDKeyInfoIterator.prototype.next = function () {\n    var baseDerivationPath = this._parentDerivedKeyInfo.baseDerivationPath;\n    var derivationIndex = this._index;\n    var fullDerivationPath = \"m/\" + baseDerivationPath + \"/\" + derivationIndex;\n    var path = \"m/\" + derivationIndex;\n\n    var hdKey = this._parentDerivedKeyInfo.hdKey.derive(path);\n\n    var address = exports.walletUtils.addressOfHDKey(hdKey);\n    var derivedKey = {\n      address: address,\n      hdKey: hdKey,\n      baseDerivationPath: baseDerivationPath,\n      derivationPath: fullDerivationPath\n    };\n    var isDone = this._index === this._searchLimit;\n    this._index++;\n    return {\n      done: isDone,\n      value: derivedKey\n    };\n  };\n\n  DerivedHDKeyInfoIterator.prototype[Symbol.iterator] = function () {\n    return this;\n  };\n\n  return DerivedHDKeyInfoIterator;\n}();\n\nexports.walletUtils = {\n  calculateDerivedHDKeyInfos: function (parentDerivedKeyInfo, numberOfKeys) {\n    var e_1, _a;\n\n    var derivedKeys = [];\n    var derivedKeyIterator = new DerivedHDKeyInfoIterator(parentDerivedKeyInfo, numberOfKeys);\n\n    try {\n      for (var derivedKeyIterator_1 = __values(derivedKeyIterator), derivedKeyIterator_1_1 = derivedKeyIterator_1.next(); !derivedKeyIterator_1_1.done; derivedKeyIterator_1_1 = derivedKeyIterator_1.next()) {\n        var key = derivedKeyIterator_1_1.value;\n        derivedKeys.push(key);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (derivedKeyIterator_1_1 && !derivedKeyIterator_1_1.done && (_a = derivedKeyIterator_1.return)) _a.call(derivedKeyIterator_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    return derivedKeys;\n  },\n  findDerivedKeyInfoForAddressIfExists: function (address, parentDerivedKeyInfo, searchLimit) {\n    var e_2, _a;\n\n    var lowercaseAddress = address.toLowerCase();\n    var matchedKey;\n    var derivedKeyIterator = new DerivedHDKeyInfoIterator(parentDerivedKeyInfo, searchLimit);\n\n    try {\n      for (var derivedKeyIterator_2 = __values(derivedKeyIterator), derivedKeyIterator_2_1 = derivedKeyIterator_2.next(); !derivedKeyIterator_2_1.done; derivedKeyIterator_2_1 = derivedKeyIterator_2.next()) {\n        var key = derivedKeyIterator_2_1.value;\n\n        if (key.address === lowercaseAddress) {\n          matchedKey = key;\n          break;\n        }\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (derivedKeyIterator_2_1 && !derivedKeyIterator_2_1.done && (_a = derivedKeyIterator_2.return)) _a.call(derivedKeyIterator_2);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n\n    return matchedKey;\n  },\n  addressOfHDKey: function (hdKey) {\n    var shouldSanitizePublicKey = true;\n    var derivedPublicKey = hdKey.publicKey;\n    var ethereumAddressUnprefixed = ethUtil.publicToAddress(derivedPublicKey, shouldSanitizePublicKey).toString('hex');\n    var address = ethUtil.addHexPrefix(ethereumAddressUnprefixed).toLowerCase();\n    return address;\n  }\n};","map":null,"metadata":{},"sourceType":"script"}