{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar assert_1 = require(\"@0x/assert\");\n\nvar json_schemas_1 = require(\"@0x/json-schemas\");\n\nvar utils_1 = require(\"@0x/utils\");\n\nvar ethereum_types_1 = require(\"ethereum-types\");\n\nvar _ = require(\"lodash\");\n\nvar marshaller_1 = require(\"./marshaller\");\n\nvar types_1 = require(\"./types\");\n\nvar utils_2 = require(\"./utils\");\n\nvar BASE_TEN = 10; // These are unique identifiers contained in the response of the\n// web3_clientVersion call.\n\nvar uniqueVersionIds = {\n  geth: 'Geth',\n  ganache: 'EthereumJS TestRPC'\n};\n/**\n * An alternative to the Web3.js library that provides a consistent, clean, promise-based interface.\n */\n\nvar Web3Wrapper =\n/** @class */\nfunction () {\n  /**\n   * Instantiates a new Web3Wrapper.\n   * @param   provider    The Web3 provider instance you would like the Web3Wrapper to use for interacting with\n   *                      the backing Ethereum node.\n   * @param   callAndTxnDefaults  Override Call and Txn Data defaults sent with RPC requests to the backing Ethereum node.\n   * @return  An instance of the Web3Wrapper class.\n   */\n  function Web3Wrapper(supportedProvider, callAndTxnDefaults) {\n    if (callAndTxnDefaults === void 0) {\n      callAndTxnDefaults = {};\n    }\n    /**\n     * Flag to check if this instance is of type Web3Wrapper\n     */\n\n\n    this.isZeroExWeb3Wrapper = true;\n    this.abiDecoder = new utils_1.AbiDecoder([]);\n    this._supportedProvider = supportedProvider;\n    this._provider = utils_1.providerUtils.standardizeOrThrow(supportedProvider);\n    this._callAndTxnDefaults = callAndTxnDefaults;\n    this._jsonRpcRequestId = 1;\n  }\n  /**\n   * Check if an address is a valid Ethereum address\n   * @param address Address to check\n   * @returns Whether the address is a valid Ethereum address\n   */\n\n\n  Web3Wrapper.isAddress = function (address) {\n    return utils_1.addressUtils.isAddress(address);\n  };\n  /**\n   * A unit amount is defined as the amount of a token above the specified decimal places (integer part).\n   * E.g: If a currency has 18 decimal places, 1e18 or one quintillion of the currency is equivalent\n   * to 1 unit.\n   * @param   amount      The amount in baseUnits that you would like converted to units.\n   * @param   decimals    The number of decimal places the unit amount has.\n   * @return  The amount in units.\n   */\n\n\n  Web3Wrapper.toUnitAmount = function (amount, decimals) {\n    assert_1.assert.isValidBaseUnitAmount('amount', amount);\n    assert_1.assert.isNumber('decimals', decimals);\n    var aUnit = new utils_1.BigNumber(BASE_TEN).pow(decimals);\n    var unit = amount.div(aUnit);\n    return unit;\n  };\n  /**\n   * A baseUnit is defined as the smallest denomination of a token. An amount expressed in baseUnits\n   * is the amount expressed in the smallest denomination.\n   * E.g: 1 unit of a token with 18 decimal places is expressed in baseUnits as 1000000000000000000\n   * @param   amount      The amount of units that you would like converted to baseUnits.\n   * @param   decimals    The number of decimal places the unit amount has.\n   * @return  The amount in baseUnits.\n   */\n\n\n  Web3Wrapper.toBaseUnitAmount = function (amount, decimals) {\n    assert_1.assert.isBigNumber('amount', amount);\n    assert_1.assert.isNumber('decimals', decimals);\n    var unit = new utils_1.BigNumber(BASE_TEN).pow(decimals);\n    var baseUnitAmount = amount.times(unit);\n    var hasDecimals = baseUnitAmount.decimalPlaces() !== 0;\n\n    if (hasDecimals) {\n      throw new Error(\"Invalid unit amount: \" + amount.toString() + \" - Too many decimal places\");\n    }\n\n    return baseUnitAmount;\n  };\n  /**\n   * Convert an Ether amount from ETH to Wei\n   * @param ethAmount Amount of Ether to convert to wei\n   * @returns Amount in wei\n   */\n\n\n  Web3Wrapper.toWei = function (ethAmount) {\n    assert_1.assert.isBigNumber('ethAmount', ethAmount);\n    var ETH_DECIMALS = 18;\n    var balanceWei = Web3Wrapper.toBaseUnitAmount(ethAmount, ETH_DECIMALS);\n    return balanceWei;\n  };\n\n  Web3Wrapper._assertBlockParam = function (blockParam) {\n    if (_.isNumber(blockParam)) {\n      return;\n    } else if (_.isString(blockParam)) {\n      assert_1.assert.doesBelongToStringEnum('blockParam', blockParam, ethereum_types_1.BlockParamLiteral);\n    }\n  };\n\n  Web3Wrapper._assertBlockParamOrString = function (blockParam) {\n    try {\n      Web3Wrapper._assertBlockParam(blockParam);\n    } catch (err) {\n      try {\n        assert_1.assert.isHexString('blockParam', blockParam);\n        return;\n      } catch (err) {\n        throw new Error(\"Expected blockParam to be of type \\\"string | BlockParam\\\", encountered \" + blockParam);\n      }\n    }\n  };\n\n  Web3Wrapper._normalizeTxReceiptStatus = function (status) {\n    // Transaction status might have four values\n    // undefined - Testrpc and other old clients\n    // null - New clients on old transactions\n    // number - Parity\n    // hex - Geth\n    if (_.isString(status)) {\n      return utils_2.utils.convertHexToNumber(status);\n    } else if (status === undefined) {\n      return null;\n    } else {\n      return status;\n    }\n  };\n  /**\n   * Get the contract defaults set to the Web3Wrapper instance\n   * @return  CallAndTxnData defaults (e.g gas, gasPrice, nonce, etc...)\n   */\n\n\n  Web3Wrapper.prototype.getContractDefaults = function () {\n    return this._callAndTxnDefaults;\n  };\n  /**\n   * Retrieve the Web3 provider\n   * @return  Web3 provider instance\n   */\n\n\n  Web3Wrapper.prototype.getProvider = function () {\n    return this._supportedProvider;\n  };\n  /**\n   * Update the used Web3 provider\n   * @param provider The new Web3 provider to be set\n   */\n\n\n  Web3Wrapper.prototype.setProvider = function (supportedProvider) {\n    var provider = utils_1.providerUtils.standardizeOrThrow(supportedProvider);\n    this._provider = provider;\n  };\n  /**\n   * Check whether an address is available through the backing provider. This can be\n   * useful if you want to know whether a user can sign messages or transactions from\n   * a given Ethereum address.\n   * @param senderAddress Address to check availability for\n   * @returns Whether the address is available through the provider.\n   */\n\n\n  Web3Wrapper.prototype.isSenderAddressAvailableAsync = function (senderAddress) {\n    return __awaiter(this, void 0, void 0, function () {\n      var addresses, normalizedAddress;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isETHAddressHex('senderAddress', senderAddress);\n            return [4\n            /*yield*/\n            , this.getAvailableAddressesAsync()];\n\n          case 1:\n            addresses = _a.sent();\n            normalizedAddress = senderAddress.toLowerCase();\n            return [2\n            /*return*/\n            , _.includes(addresses, normalizedAddress)];\n        }\n      });\n    });\n  };\n  /**\n   * Fetch the backing Ethereum node's version string (e.g `MetaMask/v4.2.0`)\n   * @returns Ethereum node's version string\n   */\n\n\n  Web3Wrapper.prototype.getNodeVersionAsync = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var nodeVersion;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'web3_clientVersion'\n            })];\n\n          case 1:\n            nodeVersion = _a.sent();\n            return [2\n            /*return*/\n            , nodeVersion];\n        }\n      });\n    });\n  };\n  /**\n   * Fetches the networkId of the backing Ethereum node\n   * @returns The network id\n   */\n\n\n  Web3Wrapper.prototype.getNetworkIdAsync = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var networkIdStr, networkId;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'net_version'\n            })];\n\n          case 1:\n            networkIdStr = _a.sent();\n            networkId = _.parseInt(networkIdStr);\n            return [2\n            /*return*/\n            , networkId];\n        }\n      });\n    });\n  };\n  /**\n   * Retrieves the transaction receipt for a given transaction hash if found\n   * @param txHash Transaction hash\n   * @returns The transaction receipt, including it's status (0: failed, 1: succeeded). Returns undefined if transaction not found.\n   */\n\n\n  Web3Wrapper.prototype.getTransactionReceiptIfExistsAsync = function (txHash) {\n    return __awaiter(this, void 0, void 0, function () {\n      var transactionReceiptRpc, transactionReceipt;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isHexString('txHash', txHash);\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'eth_getTransactionReceipt',\n              params: [txHash]\n            })];\n\n          case 1:\n            transactionReceiptRpc = _a.sent(); // HACK Parity can return a pending transaction receipt. We check for a non null\n            // block number before continuing with returning a fully realised receipt.\n            // ref: https://github.com/paritytech/parity-ethereum/issues/1180\n\n            if (transactionReceiptRpc !== null && transactionReceiptRpc.blockNumber !== null) {\n              transactionReceiptRpc.status = Web3Wrapper._normalizeTxReceiptStatus(transactionReceiptRpc.status);\n              transactionReceipt = marshaller_1.marshaller.unmarshalTransactionReceipt(transactionReceiptRpc);\n              return [2\n              /*return*/\n              , transactionReceipt];\n            } else {\n              return [2\n              /*return*/\n              , undefined];\n            }\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Retrieves the transaction data for a given transaction\n   * @param txHash Transaction hash\n   * @returns The raw transaction data\n   */\n\n\n  Web3Wrapper.prototype.getTransactionByHashAsync = function (txHash) {\n    return __awaiter(this, void 0, void 0, function () {\n      var transactionRpc, transaction;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isHexString('txHash', txHash);\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'eth_getTransactionByHash',\n              params: [txHash]\n            })];\n\n          case 1:\n            transactionRpc = _a.sent();\n            transaction = marshaller_1.marshaller.unmarshalTransaction(transactionRpc);\n            return [2\n            /*return*/\n            , transaction];\n        }\n      });\n    });\n  };\n  /**\n   * Retrieves an accounts Ether balance in wei\n   * @param owner Account whose balance you wish to check\n   * @param defaultBlock The block depth at which to fetch the balance (default=latest)\n   * @returns Balance in wei\n   */\n\n\n  Web3Wrapper.prototype.getBalanceInWeiAsync = function (owner, defaultBlock) {\n    return __awaiter(this, void 0, void 0, function () {\n      var marshalledDefaultBlock, encodedOwner, balanceInWei;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isETHAddressHex('owner', owner);\n\n            if (defaultBlock !== undefined) {\n              Web3Wrapper._assertBlockParam(defaultBlock);\n            }\n\n            marshalledDefaultBlock = marshaller_1.marshaller.marshalBlockParam(defaultBlock);\n            encodedOwner = marshaller_1.marshaller.marshalAddress(owner);\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'eth_getBalance',\n              params: [encodedOwner, marshalledDefaultBlock]\n            })];\n\n          case 1:\n            balanceInWei = _a.sent(); // Rewrap in a new BigNumber\n\n            return [2\n            /*return*/\n            , new utils_1.BigNumber(balanceInWei)];\n        }\n      });\n    });\n  };\n  /**\n   * Check if a contract exists at a given address\n   * @param address Address to which to check\n   * @returns Whether or not contract code was found at the supplied address\n   */\n\n\n  Web3Wrapper.prototype.doesContractExistAtAddressAsync = function (address) {\n    return __awaiter(this, void 0, void 0, function () {\n      var code, isCodeEmpty;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isETHAddressHex('address', address);\n            return [4\n            /*yield*/\n            , this.getContractCodeAsync(address)];\n\n          case 1:\n            code = _a.sent();\n            isCodeEmpty = /^0x0{0,40}$/i.test(code);\n            return [2\n            /*return*/\n            , !isCodeEmpty];\n        }\n      });\n    });\n  };\n  /**\n   * Gets the contract code by address\n   * @param  address Address of the contract\n   * @param defaultBlock Block height at which to make the call. Defaults to `latest`\n   * @return Code of the contract\n   */\n\n\n  Web3Wrapper.prototype.getContractCodeAsync = function (address, defaultBlock) {\n    return __awaiter(this, void 0, void 0, function () {\n      var marshalledDefaultBlock, encodedAddress, code;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isETHAddressHex('address', address);\n\n            if (defaultBlock !== undefined) {\n              Web3Wrapper._assertBlockParam(defaultBlock);\n            }\n\n            marshalledDefaultBlock = marshaller_1.marshaller.marshalBlockParam(defaultBlock);\n            encodedAddress = marshaller_1.marshaller.marshalAddress(address);\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'eth_getCode',\n              params: [encodedAddress, marshalledDefaultBlock]\n            })];\n\n          case 1:\n            code = _a.sent();\n            return [2\n            /*return*/\n            , code];\n        }\n      });\n    });\n  };\n  /**\n   * Gets the debug trace of a transaction\n   * @param  txHash Hash of the transactuon to get a trace for\n   * @param  traceParams Config object allowing you to specify if you need memory/storage/stack traces.\n   * @return Transaction trace\n   */\n\n\n  Web3Wrapper.prototype.getTransactionTraceAsync = function (txHash, traceParams) {\n    return __awaiter(this, void 0, void 0, function () {\n      var trace;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isHexString('txHash', txHash);\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'debug_traceTransaction',\n              params: [txHash, traceParams]\n            })];\n\n          case 1:\n            trace = _a.sent();\n            return [2\n            /*return*/\n            , trace];\n        }\n      });\n    });\n  };\n  /**\n   * Sign a message with a specific address's private key (`eth_sign`)\n   * @param address Address of signer\n   * @param message Message to sign\n   * @returns Signature string (might be VRS or RSV depending on the Signer)\n   */\n\n\n  Web3Wrapper.prototype.signMessageAsync = function (address, message) {\n    return __awaiter(this, void 0, void 0, function () {\n      var signData;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isETHAddressHex('address', address);\n            assert_1.assert.isString('message', message); // TODO: Should this be stricter? Hex string?\n\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'eth_sign',\n              params: [address, message]\n            })];\n\n          case 1:\n            signData = _a.sent();\n            return [2\n            /*return*/\n            , signData];\n        }\n      });\n    });\n  };\n  /**\n   * Sign an EIP712 typed data message with a specific address's private key (`eth_signTypedData`)\n   * @param address Address of signer\n   * @param typedData Typed data message to sign\n   * @returns Signature string (as RSV)\n   */\n\n\n  Web3Wrapper.prototype.signTypedDataAsync = function (address, typedData) {\n    return __awaiter(this, void 0, void 0, function () {\n      var signData;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isETHAddressHex('address', address);\n            assert_1.assert.doesConformToSchema('typedData', typedData, json_schemas_1.schemas.eip712TypedDataSchema);\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'eth_signTypedData',\n              params: [address, typedData]\n            })];\n\n          case 1:\n            signData = _a.sent();\n            return [2\n            /*return*/\n            , signData];\n        }\n      });\n    });\n  };\n  /**\n   * Fetches the latest block number\n   * @returns Block number\n   */\n\n\n  Web3Wrapper.prototype.getBlockNumberAsync = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var blockNumberHex, blockNumber;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'eth_blockNumber',\n              params: []\n            })];\n\n          case 1:\n            blockNumberHex = _a.sent();\n            blockNumber = utils_2.utils.convertHexToNumberOrNull(blockNumberHex);\n            return [2\n            /*return*/\n            , blockNumber];\n        }\n      });\n    });\n  };\n  /**\n   * Fetch a specific Ethereum block without transaction data\n   * @param blockParam The block you wish to fetch (blockHash, blockNumber or blockLiteral)\n   * @returns The requested block without transaction data, or undefined if block was not found\n   * (e.g the node isn't fully synced, there was a block re-org and the requested block was uncles, etc...)\n   */\n\n\n  Web3Wrapper.prototype.getBlockIfExistsAsync = function (blockParam) {\n    return __awaiter(this, void 0, void 0, function () {\n      var encodedBlockParam, method, shouldIncludeTransactionData, blockWithoutTransactionDataWithHexValuesOrNull, blockWithoutTransactionDataIfExists;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            Web3Wrapper._assertBlockParamOrString(blockParam);\n\n            encodedBlockParam = marshaller_1.marshaller.marshalBlockParam(blockParam);\n            method = utils_2.utils.isHexStrict(blockParam) ? 'eth_getBlockByHash' : 'eth_getBlockByNumber';\n            shouldIncludeTransactionData = false;\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: method,\n              params: [encodedBlockParam, shouldIncludeTransactionData]\n            })];\n\n          case 1:\n            blockWithoutTransactionDataWithHexValuesOrNull = _a.sent();\n\n            if (blockWithoutTransactionDataWithHexValuesOrNull !== null) {\n              blockWithoutTransactionDataIfExists = marshaller_1.marshaller.unmarshalIntoBlockWithoutTransactionData(blockWithoutTransactionDataWithHexValuesOrNull);\n            }\n\n            return [2\n            /*return*/\n            , blockWithoutTransactionDataIfExists];\n        }\n      });\n    });\n  };\n  /**\n   * Fetch a specific Ethereum block with transaction data\n   * @param blockParam The block you wish to fetch (blockHash, blockNumber or blockLiteral)\n   * @returns The requested block with transaction data\n   */\n\n\n  Web3Wrapper.prototype.getBlockWithTransactionDataAsync = function (blockParam) {\n    return __awaiter(this, void 0, void 0, function () {\n      var encodedBlockParam, method, shouldIncludeTransactionData, blockWithTransactionDataWithHexValues, blockWithoutTransactionData;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            Web3Wrapper._assertBlockParamOrString(blockParam);\n\n            encodedBlockParam = blockParam;\n\n            if (_.isNumber(blockParam)) {\n              encodedBlockParam = utils_2.utils.numberToHex(blockParam);\n            }\n\n            method = utils_2.utils.isHexStrict(blockParam) ? 'eth_getBlockByHash' : 'eth_getBlockByNumber';\n            shouldIncludeTransactionData = true;\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: method,\n              params: [encodedBlockParam, shouldIncludeTransactionData]\n            })];\n\n          case 1:\n            blockWithTransactionDataWithHexValues = _a.sent();\n            blockWithoutTransactionData = marshaller_1.marshaller.unmarshalIntoBlockWithTransactionData(blockWithTransactionDataWithHexValues);\n            return [2\n            /*return*/\n            , blockWithoutTransactionData];\n        }\n      });\n    });\n  };\n  /**\n   * Fetch a block's timestamp\n   * @param blockParam The block you wish to fetch (blockHash, blockNumber or blockLiteral)\n   * @returns The block's timestamp\n   */\n\n\n  Web3Wrapper.prototype.getBlockTimestampAsync = function (blockParam) {\n    return __awaiter(this, void 0, void 0, function () {\n      var blockIfExists;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            Web3Wrapper._assertBlockParamOrString(blockParam);\n\n            return [4\n            /*yield*/\n            , this.getBlockIfExistsAsync(blockParam)];\n\n          case 1:\n            blockIfExists = _a.sent();\n\n            if (blockIfExists === undefined) {\n              throw new Error(\"Failed to fetch block with blockParam: \" + JSON.stringify(blockParam));\n            }\n\n            return [2\n            /*return*/\n            , blockIfExists.timestamp];\n        }\n      });\n    });\n  };\n  /**\n   * Retrieve the user addresses available through the backing provider\n   * @returns Available user addresses\n   */\n\n\n  Web3Wrapper.prototype.getAvailableAddressesAsync = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var addresses, normalizedAddresses;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'eth_accounts',\n              params: []\n            })];\n\n          case 1:\n            addresses = _a.sent();\n            normalizedAddresses = _.map(addresses, function (address) {\n              return address.toLowerCase();\n            });\n            return [2\n            /*return*/\n            , normalizedAddresses];\n        }\n      });\n    });\n  };\n  /**\n   * Take a snapshot of the blockchain state on a TestRPC/Ganache local node\n   * @returns The snapshot id. This can be used to revert to this snapshot\n   */\n\n\n  Web3Wrapper.prototype.takeSnapshotAsync = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var snapshotId, _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _a = Number;\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'evm_snapshot',\n              params: []\n            })];\n\n          case 1:\n            snapshotId = _a.apply(void 0, [_b.sent()]);\n            return [2\n            /*return*/\n            , snapshotId];\n        }\n      });\n    });\n  };\n  /**\n   * Revert the blockchain state to a previous snapshot state on TestRPC/Ganache local node\n   * @param snapshotId snapshot id to revert to\n   * @returns Whether the revert was successful\n   */\n\n\n  Web3Wrapper.prototype.revertSnapshotAsync = function (snapshotId) {\n    return __awaiter(this, void 0, void 0, function () {\n      var didRevert;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isNumber('snapshotId', snapshotId);\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'evm_revert',\n              params: [snapshotId]\n            })];\n\n          case 1:\n            didRevert = _a.sent();\n            return [2\n            /*return*/\n            , didRevert];\n        }\n      });\n    });\n  };\n  /**\n   * Mine a block on a TestRPC/Ganache local node\n   */\n\n\n  Web3Wrapper.prototype.mineBlockAsync = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'evm_mine',\n              params: []\n            })];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Increase the next blocks timestamp on TestRPC/Ganache or Geth local node.\n   * Will throw if provider is neither TestRPC/Ganache or Geth.\n   * @param timeDelta Amount of time to add in seconds\n   */\n\n\n  Web3Wrapper.prototype.increaseTimeAsync = function (timeDelta) {\n    return __awaiter(this, void 0, void 0, function () {\n      var version;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isNumber('timeDelta', timeDelta);\n            return [4\n            /*yield*/\n            , this.getNodeVersionAsync()];\n\n          case 1:\n            version = _a.sent();\n\n            if (_.includes(version, uniqueVersionIds.geth)) {\n              return [2\n              /*return*/\n              , this.sendRawPayloadAsync({\n                method: 'debug_increaseTime',\n                params: [timeDelta]\n              })];\n            } else if (_.includes(version, uniqueVersionIds.ganache)) {\n              return [2\n              /*return*/\n              , this.sendRawPayloadAsync({\n                method: 'evm_increaseTime',\n                params: [timeDelta]\n              })];\n            } else {\n              throw new Error(\"Unknown client version: \" + version);\n            }\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Retrieve smart contract logs for a given filter\n   * @param filter Parameters by which to filter which logs to retrieve\n   * @returns The corresponding log entries\n   */\n\n\n  Web3Wrapper.prototype.getLogsAsync = function (filter) {\n    return __awaiter(this, void 0, void 0, function () {\n      var fromBlock, toBlock, serializedFilter, payload, rawLogs, formattedLogs;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (filter.blockHash !== undefined && (filter.fromBlock !== undefined || filter.toBlock !== undefined)) {\n              throw new Error(\"Cannot specify 'blockHash' as well as 'fromBlock'/'toBlock' in the filter supplied to 'getLogsAsync'\");\n            }\n\n            fromBlock = filter.fromBlock;\n\n            if (_.isNumber(fromBlock)) {\n              fromBlock = utils_2.utils.numberToHex(fromBlock);\n            }\n\n            toBlock = filter.toBlock;\n\n            if (_.isNumber(toBlock)) {\n              toBlock = utils_2.utils.numberToHex(toBlock);\n            }\n\n            serializedFilter = __assign({}, filter, {\n              fromBlock: fromBlock,\n              toBlock: toBlock\n            });\n            payload = {\n              method: 'eth_getLogs',\n              params: [serializedFilter]\n            };\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync(payload)];\n\n          case 1:\n            rawLogs = _a.sent();\n            formattedLogs = _.map(rawLogs, marshaller_1.marshaller.unmarshalLog.bind(marshaller_1.marshaller));\n            return [2\n            /*return*/\n            , formattedLogs];\n        }\n      });\n    });\n  };\n  /**\n   * Calculate the estimated gas cost for a given transaction\n   * @param txData Transaction data\n   * @returns Estimated gas cost\n   */\n\n\n  Web3Wrapper.prototype.estimateGasAsync = function (txData) {\n    return __awaiter(this, void 0, void 0, function () {\n      var txDataHex, gasHex, gas;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.doesConformToSchema('txData', txData, json_schemas_1.schemas.txDataSchema, [json_schemas_1.schemas.addressSchema, json_schemas_1.schemas.numberSchema, json_schemas_1.schemas.jsNumber]);\n            txDataHex = marshaller_1.marshaller.marshalTxData(txData);\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'eth_estimateGas',\n              params: [txDataHex]\n            })];\n\n          case 1:\n            gasHex = _a.sent();\n            gas = utils_2.utils.convertHexToNumber(gasHex);\n            return [2\n            /*return*/\n            , gas];\n        }\n      });\n    });\n  };\n  /**\n   * Call a smart contract method at a given block height\n   * @param callData Call data\n   * @param defaultBlock Block height at which to make the call. Defaults to `latest`\n   * @returns The raw call result\n   */\n\n\n  Web3Wrapper.prototype.callAsync = function (callData, defaultBlock) {\n    return __awaiter(this, void 0, void 0, function () {\n      var marshalledDefaultBlock, callDataHex, rawCallResult;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.doesConformToSchema('callData', callData, json_schemas_1.schemas.callDataSchema, [json_schemas_1.schemas.addressSchema, json_schemas_1.schemas.numberSchema, json_schemas_1.schemas.jsNumber]);\n\n            if (defaultBlock !== undefined) {\n              Web3Wrapper._assertBlockParam(defaultBlock);\n            }\n\n            marshalledDefaultBlock = marshaller_1.marshaller.marshalBlockParam(defaultBlock);\n            callDataHex = marshaller_1.marshaller.marshalCallData(callData);\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'eth_call',\n              params: [callDataHex, marshalledDefaultBlock]\n            })];\n\n          case 1:\n            rawCallResult = _a.sent();\n            return [2\n            /*return*/\n            , rawCallResult];\n        }\n      });\n    });\n  };\n  /**\n   * Send a transaction\n   * @param txData Transaction data\n   * @returns Transaction hash\n   */\n\n\n  Web3Wrapper.prototype.sendTransactionAsync = function (txData) {\n    return __awaiter(this, void 0, void 0, function () {\n      var txDataHex, txHash;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.doesConformToSchema('txData', txData, json_schemas_1.schemas.txDataSchema, [json_schemas_1.schemas.addressSchema, json_schemas_1.schemas.numberSchema, json_schemas_1.schemas.jsNumber]);\n            txDataHex = marshaller_1.marshaller.marshalTxData(txData);\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'eth_sendTransaction',\n              params: [txDataHex]\n            })];\n\n          case 1:\n            txHash = _a.sent();\n            return [2\n            /*return*/\n            , txHash];\n        }\n      });\n    });\n  };\n  /**\n   * Waits for a transaction to be mined and returns the transaction receipt.\n   * Note that just because a transaction was mined does not mean it was\n   * successful. You need to check the status code of the transaction receipt\n   * to find out if it was successful, or use the helper method\n   * awaitTransactionSuccessAsync.\n   * @param   txHash            Transaction hash\n   * @param   pollingIntervalMs How often (in ms) should we check if the transaction is mined.\n   * @param   timeoutMs         How long (in ms) to poll for transaction mined until aborting.\n   * @return  Transaction receipt with decoded log args.\n   */\n\n\n  Web3Wrapper.prototype.awaitTransactionMinedAsync = function (txHash, pollingIntervalMs, timeoutMs) {\n    if (pollingIntervalMs === void 0) {\n      pollingIntervalMs = 1000;\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var transactionReceipt, logsWithDecodedArgs, transactionReceiptWithDecodedLogArgs, wasTimeoutExceeded, txReceiptPromise, txReceipt;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isHexString('txHash', txHash);\n            assert_1.assert.isNumber('pollingIntervalMs', pollingIntervalMs);\n\n            if (timeoutMs !== undefined) {\n              assert_1.assert.isNumber('timeoutMs', timeoutMs);\n            }\n\n            return [4\n            /*yield*/\n            , this.getTransactionReceiptIfExistsAsync(txHash)];\n\n          case 1:\n            transactionReceipt = _a.sent();\n\n            if (transactionReceipt !== undefined) {\n              logsWithDecodedArgs = _.map(transactionReceipt.logs, this.abiDecoder.tryToDecodeLogOrNoop.bind(this.abiDecoder));\n              transactionReceiptWithDecodedLogArgs = __assign({}, transactionReceipt, {\n                logs: logsWithDecodedArgs\n              });\n              return [2\n              /*return*/\n              , transactionReceiptWithDecodedLogArgs];\n            }\n\n            wasTimeoutExceeded = false;\n\n            if (timeoutMs) {\n              setTimeout(function () {\n                return wasTimeoutExceeded = true;\n              }, timeoutMs);\n            }\n\n            txReceiptPromise = new Promise(function (resolve, reject) {\n              var intervalId = utils_1.intervalUtils.setAsyncExcludingInterval(function () {\n                return __awaiter(_this, void 0, void 0, function () {\n                  var logsWithDecodedArgs, transactionReceiptWithDecodedLogArgs;\n                  return __generator(this, function (_a) {\n                    switch (_a.label) {\n                      case 0:\n                        if (wasTimeoutExceeded) {\n                          utils_1.intervalUtils.clearAsyncExcludingInterval(intervalId);\n                          return [2\n                          /*return*/\n                          , reject(types_1.Web3WrapperErrors.TransactionMiningTimeout)];\n                        }\n\n                        return [4\n                        /*yield*/\n                        , this.getTransactionReceiptIfExistsAsync(txHash)];\n\n                      case 1:\n                        transactionReceipt = _a.sent();\n\n                        if (transactionReceipt !== undefined) {\n                          utils_1.intervalUtils.clearAsyncExcludingInterval(intervalId);\n                          logsWithDecodedArgs = _.map(transactionReceipt.logs, this.abiDecoder.tryToDecodeLogOrNoop.bind(this.abiDecoder));\n                          transactionReceiptWithDecodedLogArgs = __assign({}, transactionReceipt, {\n                            logs: logsWithDecodedArgs\n                          });\n                          resolve(transactionReceiptWithDecodedLogArgs);\n                        }\n\n                        return [2\n                        /*return*/\n                        ];\n                    }\n                  });\n                });\n              }, pollingIntervalMs, function (err) {\n                utils_1.intervalUtils.clearAsyncExcludingInterval(intervalId);\n                reject(err);\n              });\n            });\n            return [4\n            /*yield*/\n            , txReceiptPromise];\n\n          case 2:\n            txReceipt = _a.sent();\n            return [2\n            /*return*/\n            , txReceipt];\n        }\n      });\n    });\n  };\n  /**\n   * Waits for a transaction to be mined and returns the transaction receipt.\n   * Unlike awaitTransactionMinedAsync, it will throw if the receipt has a\n   * status that is not equal to 1. A status of 0 or null indicates that the\n   * transaction was mined, but failed. See:\n   * https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethgettransactionreceipt\n   * @param   txHash            Transaction hash\n   * @param   pollingIntervalMs How often (in ms) should we check if the transaction is mined.\n   * @param   timeoutMs         How long (in ms) to poll for transaction mined until aborting.\n   * @return  Transaction receipt with decoded log args.\n   */\n\n\n  Web3Wrapper.prototype.awaitTransactionSuccessAsync = function (txHash, pollingIntervalMs, timeoutMs) {\n    if (pollingIntervalMs === void 0) {\n      pollingIntervalMs = 1000;\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var receipt;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.awaitTransactionMinedAsync(txHash, pollingIntervalMs, timeoutMs)];\n\n          case 1:\n            receipt = _a.sent();\n\n            if (receipt.status !== 1) {\n              throw new Error(\"Transaction failed: \" + txHash);\n            }\n\n            return [2\n            /*return*/\n            , receipt];\n        }\n      });\n    });\n  };\n  /**\n   * Calls the 'debug_setHead' JSON RPC method, which sets the current head of\n   * the local chain by block number. Note, this is a destructive action and\n   * may severely damage your chain. Use with extreme caution. As of now, this\n   * is only supported by Geth. It sill throw if the 'debug_setHead' method is\n   * not supported.\n   * @param  blockNumber The block number to reset to.\n   */\n\n\n  Web3Wrapper.prototype.setHeadAsync = function (blockNumber) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isNumber('blockNumber', blockNumber);\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'debug_setHead',\n              params: [utils_2.utils.numberToHex(blockNumber)]\n            })];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Sends a raw Ethereum JSON RPC payload and returns the response's `result` key\n   * @param payload A partial JSON RPC payload. No need to include version, id, params (if none needed)\n   * @return The contents nested under the result key of the response body\n   */\n\n\n  Web3Wrapper.prototype.sendRawPayloadAsync = function (payload) {\n    return __awaiter(this, void 0, void 0, function () {\n      var sendAsync, payloadWithDefaults, response, result;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            sendAsync = this._provider.sendAsync.bind(this._provider);\n            payloadWithDefaults = __assign({\n              id: this._jsonRpcRequestId++,\n              params: [],\n              jsonrpc: '2.0'\n            }, payload);\n            return [4\n            /*yield*/\n            , utils_1.promisify(sendAsync)(payloadWithDefaults)];\n\n          case 1:\n            response = _a.sent();\n\n            if (response.error) {\n              throw new Error(response.error.message);\n            }\n\n            result = response.result;\n            return [2\n            /*return*/\n            , result];\n        }\n      });\n    });\n  };\n  /**\n   * Returns either NodeType.Geth or NodeType.Ganache depending on the type of\n   * the backing Ethereum node. Throws for any other type of node.\n   */\n\n\n  Web3Wrapper.prototype.getNodeTypeAsync = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var version;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.getNodeVersionAsync()];\n\n          case 1:\n            version = _a.sent();\n\n            if (_.includes(version, uniqueVersionIds.geth)) {\n              return [2\n              /*return*/\n              , types_1.NodeType.Geth];\n            } else if (_.includes(version, uniqueVersionIds.ganache)) {\n              return [2\n              /*return*/\n              , types_1.NodeType.Ganache];\n            } else {\n              throw new Error(\"Unknown client version: \" + version);\n            }\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  return Web3Wrapper;\n}(); // tslint:disable-line:max-file-line-count\n\n\nexports.Web3Wrapper = Web3Wrapper;","map":null,"metadata":{},"sourceType":"script"}