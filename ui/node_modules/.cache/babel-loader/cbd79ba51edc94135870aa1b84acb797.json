{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _ = require(\"lodash\");\n\nexports.providerUtils = {\n  /**\n   * Starts the Web3ProviderEngine without excess block polling\n   * @param providerEngine The Web3ProviderEngine\n   */\n  startProviderEngine: function (providerEngine) {\n    if (providerEngine.start === undefined) {\n      throw new Error(\"Invalid Web3ProviderEngine\");\n    } // HACK: When calling start() Web3ProviderEngine starts a block polling service\n    // this continuously pulls data from the network and can result in high data usage\n    // for long running services. If used in a front end application this can cause\n    // a high amount of load on a node (one request per user per block).\n\n\n    providerEngine._ready.go();\n\n    providerEngine._running = true;\n  },\n\n  /**\n   * Standardize the supported provider types into our internal provider interface\n   * or throw if unsupported provider supplied.\n   * @param supportedProvider Potentially supported provider instance\n   * @return Provider that conforms of our internal provider interface\n   */\n  standardizeOrThrow: function (supportedProvider) {\n    if (supportedProvider === undefined) {\n      throw new Error(\"supportedProvider cannot be 'undefined'\");\n    }\n\n    var provider = {\n      isStandardizedProvider: true,\n      isMetaMask: supportedProvider.isMetaMask,\n      isParity: supportedProvider.isParity,\n      stop: supportedProvider.stop,\n      enable: supportedProvider.enable,\n      sendAsync: _.noop.bind(_)\n    }; // Case 1: We've already converted to our ZeroExProvider so noop.\n\n    if (supportedProvider.isStandardizedProvider) {\n      // tslint:disable-next-line:no-unnecessary-type-assertion\n      return supportedProvider; // Case 2: It's a compliant EIP 1193 Provider\n      // tslint:disable-next-line:no-unnecessary-type-assertion\n    } else if (supportedProvider.isEIP1193) {\n      provider.sendAsync = function (payload, callback) {\n        var method = payload.method;\n        var params = payload.params;\n        supportedProvider.send(method, params).then(function (result) {\n          callback(null, result);\n        }).catch(function (err) {\n          callback(err);\n        });\n      };\n\n      return provider; // Case 3: The provider has a `sendAsync` method, so we use it.\n    } else if (supportedProvider.sendAsync !== undefined) {\n      provider.sendAsync = supportedProvider.sendAsync.bind(supportedProvider);\n      return provider; // Case 4: The provider does not have a `sendAsync` method but does have a `send` method\n    } else if (supportedProvider.send !== undefined) {\n      // HACK(fabio): Detect if the `send` method has the old interface `send(payload, cb)` such\n      // as in versions < Web3.js@1.0.0-beta.37. If so, do a simple re-mapping\n      if (_.includes(supportedProvider.send.toString(), 'function (payload, callback)')) {\n        provider.sendAsync = supportedProvider.send.bind(supportedProvider);\n        return provider;\n      } else {\n        // If doesn't have old interface, we assume it has new interface `send(method, payload)`\n        // such as in versions > Web3.js@1.0.0-beta.38 and convert it to `sendAsync`\n        provider.sendAsync = function (payload, callback) {\n          var method = payload.method;\n          var params = payload.params;\n          supportedProvider.send(method, params).then(function (result) {\n            callback(null, result);\n          }).catch(function (err) {\n            callback(err);\n          });\n        };\n\n        return provider;\n      }\n    }\n\n    throw new Error(\"Unsupported provider found. Please make sure it conforms to one of the supported providers. See 'Provider' type in 'ethereum-types' package.\");\n  }\n};","map":null,"metadata":{},"sourceType":"script"}