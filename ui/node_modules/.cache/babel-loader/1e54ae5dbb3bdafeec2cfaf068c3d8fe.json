{"ast":null,"code":"\"use strict\";\n\nvar __values = this && this.__values || function (o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n      i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ethereum_types_1 = require(\"ethereum-types\");\n\nvar _ = require(\"lodash\");\n\nvar configured_bignumber_1 = require(\"./configured_bignumber\"); // Note(albrow): This function is unexported in ethers.js. Copying it here for\n// now.\n// Source: https://github.com/ethers-io/ethers.js/blob/884593ab76004a808bf8097e9753fb5f8dcc3067/contracts/interface.js#L30\n\n\nfunction parseEthersParams(params) {\n  var names = [];\n  var types = [];\n  params.forEach(function (param) {\n    if (param.components != null) {\n      var suffix = '';\n      var arrayBracket = param.type.indexOf('[');\n\n      if (arrayBracket >= 0) {\n        suffix = param.type.substring(arrayBracket);\n      }\n\n      var result = parseEthersParams(param.components);\n      names.push({\n        name: param.name || null,\n        names: result.names\n      });\n      types.push(\"tuple(\" + result.types.join(',') + \")\" + suffix);\n    } else {\n      names.push(param.name || null);\n      types.push(param.type);\n    }\n  });\n  return {\n    names: names,\n    types: types\n  };\n} // returns true if x is equal to y and false otherwise. Performs some minimal\n// type conversion and data massaging for x and y, depending on type. name and\n// type should typically be derived from parseEthersParams.\n\n\nfunction isAbiDataEqual(name, type, x, y) {\n  if (x === undefined && y === undefined) {\n    return true;\n  } else if (x === undefined && y !== undefined) {\n    return false;\n  } else if (x !== undefined && y === undefined) {\n    return false;\n  }\n\n  if (_.endsWith(type, '[]')) {\n    // For array types, we iterate through the elements and check each one\n    // individually. Strangely, name does not need to be changed in this\n    // case.\n    if (x.length !== y.length) {\n      return false;\n    }\n\n    var newType = _.trimEnd(type, '[]');\n\n    for (var i = 0; i < x.length; i++) {\n      if (!isAbiDataEqual(name, newType, x[i], y[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  if (_.startsWith(type, 'tuple(')) {\n    if (_.isString(name)) {\n      throw new Error('Internal error: type was tuple but names was a string');\n    } else if (name === null) {\n      throw new Error('Internal error: type was tuple but names was null');\n    } // For tuples, we iterate through the underlying values and check each\n    // one individually.\n\n\n    var types = splitTupleTypes(type);\n\n    if (types.length !== name.names.length) {\n      throw new Error(\"Internal error: parameter types/names length mismatch (\" + types.length + \" != \" + name.names.length + \")\");\n    }\n\n    for (var i = 0; i < types.length; i++) {\n      // For tuples, name is an object with a names property that is an\n      // array. As an example, for orders, name looks like:\n      //\n      //  {\n      //      name: 'orders',\n      //      names: [\n      //          'makerAddress',\n      //          // ...\n      //          'takerAssetData'\n      //      ]\n      //  }\n      //\n      var nestedName = _.isString(name.names[i]) ? name.names[i] : name.names[i].name;\n\n      if (!isAbiDataEqual(name.names[i], types[i], x[nestedName], y[nestedName])) {\n        return false;\n      }\n    }\n\n    return true;\n  } else if (type === 'address' || type === 'bytes') {\n    // HACK(albrow): ethers.js returns the checksummed address even when\n    // initially passed in a non-checksummed address. To account for that,\n    // we convert to lowercase before comparing.\n    return _.isEqual(_.toLower(x), _.toLower(y));\n  } else if (_.startsWith(type, 'uint') || _.startsWith(type, 'int')) {\n    return new configured_bignumber_1.BigNumber(x).eq(new configured_bignumber_1.BigNumber(y));\n  }\n\n  return _.isEqual(x, y);\n} // splitTupleTypes splits a tuple type string (of the form `tuple(X)` where X is\n// any other type or list of types) into its component types. It works with\n// nested tuples, so, e.g., `tuple(tuple(uint256,address),bytes32)` will yield:\n// `['tuple(uint256,address)', 'bytes32']`. It expects exactly one tuple type as\n// an argument (not an array).\n\n\nfunction splitTupleTypes(type) {\n  var e_1, _a;\n\n  if (_.endsWith(type, '[]')) {\n    throw new Error('Internal error: array types are not supported');\n  } else if (!_.startsWith(type, 'tuple(')) {\n    throw new Error(\"Internal error: expected tuple type but got non-tuple type: \" + type);\n  } // Trim the outtermost tuple().\n\n\n  var trimmedType = type.substring('tuple('.length, type.length - 1);\n  var types = [];\n  var currToken = '';\n  var parenCount = 0;\n\n  try {\n    // Tokenize the type string while keeping track of parentheses.\n    for (var trimmedType_1 = __values(trimmedType), trimmedType_1_1 = trimmedType_1.next(); !trimmedType_1_1.done; trimmedType_1_1 = trimmedType_1.next()) {\n      var char = trimmedType_1_1.value;\n\n      switch (char) {\n        case '(':\n          parenCount += 1;\n          currToken += char;\n          break;\n\n        case ')':\n          parenCount -= 1;\n          currToken += char;\n          break;\n\n        case ',':\n          if (parenCount === 0) {\n            types.push(currToken);\n            currToken = '';\n            break;\n          } else {\n            currToken += char;\n            break;\n          }\n\n        default:\n          currToken += char;\n          break;\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (trimmedType_1_1 && !trimmedType_1_1.done && (_a = trimmedType_1.return)) _a.call(trimmedType_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n\n  types.push(currToken);\n  return types;\n}\n\nexports.abiUtils = {\n  parseEthersParams: parseEthersParams,\n  isAbiDataEqual: isAbiDataEqual,\n  splitTupleTypes: splitTupleTypes,\n  parseFunctionParam: function (param) {\n    if (param.type === 'tuple') {\n      // Parse out tuple types into {type_1, type_2, ..., type_N}\n      var tupleComponents = param.components;\n\n      var paramString = _.map(tupleComponents, function (component) {\n        return exports.abiUtils.parseFunctionParam(component);\n      });\n\n      var tupleParamString = \"{\" + paramString + \"}\";\n      return tupleParamString;\n    }\n\n    return param.type;\n  },\n  getFunctionSignature: function (methodAbi) {\n    var functionName = methodAbi.name;\n\n    var parameterTypeList = _.map(methodAbi.inputs, function (param) {\n      return exports.abiUtils.parseFunctionParam(param);\n    });\n\n    var functionSignature = functionName + \"(\" + parameterTypeList + \")\";\n    return functionSignature;\n  },\n\n  /**\n   * Solidity supports function overloading whereas TypeScript does not.\n   * See: https://solidity.readthedocs.io/en/v0.4.21/contracts.html?highlight=overload#function-overloading\n   * In order to support overloaded functions, we suffix overloaded function names with an index.\n   * This index should be deterministic, regardless of function ordering within the smart contract. To do so,\n   * we assign indexes based on the alphabetical order of function signatures.\n   *\n   * E.g\n   * ['f(uint)', 'f(uint,byte32)']\n   * Should always be renamed to:\n   * ['f1(uint)', 'f2(uint,byte32)']\n   * Regardless of the order in which these these overloaded functions are declared within the contract ABI.\n   */\n  renameOverloadedMethods: function (inputContractAbi) {\n    var contractAbi = _.cloneDeep(inputContractAbi);\n\n    var methodAbis = contractAbi.filter(function (abi) {\n      return abi.type === ethereum_types_1.AbiType.Function;\n    }); // Sort method Abis into alphabetical order, by function signature\n\n    var methodAbisOrdered = _.sortBy(methodAbis, [function (methodAbi) {\n      var functionSignature = exports.abiUtils.getFunctionSignature(methodAbi);\n      return functionSignature;\n    }]); // Group method Abis by name (overloaded methods will be grouped together, in alphabetical order)\n\n\n    var methodAbisByName = {};\n\n    _.each(methodAbisOrdered, function (methodAbi) {\n      (methodAbisByName[methodAbi.name] || (methodAbisByName[methodAbi.name] = [])).push(methodAbi);\n    }); // Rename overloaded methods to overloadedMethodName1, overloadedMethodName2, ...\n\n\n    _.each(methodAbisByName, function (methodAbisWithSameName) {\n      _.each(methodAbisWithSameName, function (methodAbi, i) {\n        if (methodAbisWithSameName.length > 1) {\n          var overloadedMethodId = i + 1;\n          var sanitizedMethodName_1 = \"\" + methodAbi.name + overloadedMethodId;\n\n          var indexOfExistingAbiWithSanitizedMethodNameIfExists = _.findIndex(methodAbis, function (currentMethodAbi) {\n            return currentMethodAbi.name === sanitizedMethodName_1;\n          });\n\n          if (indexOfExistingAbiWithSanitizedMethodNameIfExists >= 0) {\n            var methodName = methodAbi.name;\n            throw new Error(\"Failed to rename overloaded method '\" + methodName + \"' to '\" + sanitizedMethodName_1 + \"'. A method with this name already exists.\");\n          }\n\n          methodAbi.name = sanitizedMethodName_1;\n        }\n      });\n    });\n\n    return contractAbi;\n  }\n};","map":null,"metadata":{},"sourceType":"script"}