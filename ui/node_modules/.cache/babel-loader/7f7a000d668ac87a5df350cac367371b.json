{"ast":null,"code":"const EventEmitter = require('events').EventEmitter;\n\nconst inherits = require('util').inherits;\n\nconst ethUtil = require('ethereumjs-util');\n\nconst EthBlockTracker = require('eth-block-tracker');\n\nconst map = require('async/map');\n\nconst eachSeries = require('async/eachSeries');\n\nconst Stoplight = require('./util/stoplight.js');\n\nconst cacheUtils = require('./util/rpc-cache-utils.js');\n\nconst createPayload = require('./util/create-payload.js');\n\nconst noop = function () {};\n\nmodule.exports = Web3ProviderEngine;\ninherits(Web3ProviderEngine, EventEmitter);\n\nfunction Web3ProviderEngine(opts) {\n  const self = this;\n  EventEmitter.call(self);\n  self.setMaxListeners(30); // parse options\n\n  opts = opts || {}; // block polling\n\n  const directProvider = {\n    sendAsync: self._handleAsync.bind(self)\n  };\n  const blockTrackerProvider = opts.blockTrackerProvider || directProvider;\n  self._blockTracker = opts.blockTracker || new EthBlockTracker({\n    provider: blockTrackerProvider,\n    pollingInterval: opts.pollingInterval || 4000\n  }); // handle new block\n\n  self._blockTracker.on('block', jsonBlock => {\n    const bufferBlock = toBufferBlock(jsonBlock);\n\n    self._setCurrentBlock(bufferBlock);\n  }); // emit block events from the block tracker\n\n\n  self._blockTracker.on('block', self.emit.bind(self, 'rawBlock'));\n\n  self._blockTracker.on('sync', self.emit.bind(self, 'sync'));\n\n  self._blockTracker.on('latest', self.emit.bind(self, 'latest')); // set initialization blocker\n\n\n  self._ready = new Stoplight(); // unblock initialization after first block\n\n  self._blockTracker.once('block', () => {\n    self._ready.go();\n  }); // local state\n\n\n  self.currentBlock = null;\n  self._providers = [];\n} // public\n\n\nWeb3ProviderEngine.prototype.start = function (cb = noop) {\n  const self = this; // start block polling\n\n  self._blockTracker.start().then(cb).catch(cb);\n};\n\nWeb3ProviderEngine.prototype.stop = function () {\n  const self = this; // stop block polling\n\n  self._blockTracker.stop();\n};\n\nWeb3ProviderEngine.prototype.addProvider = function (source) {\n  const self = this;\n\n  self._providers.push(source);\n\n  source.setEngine(this);\n};\n\nWeb3ProviderEngine.prototype.send = function (payload) {\n  throw new Error('Web3ProviderEngine does not support synchronous requests.');\n};\n\nWeb3ProviderEngine.prototype.sendAsync = function (payload, cb) {\n  const self = this;\n\n  self._ready.await(function () {\n    if (Array.isArray(payload)) {\n      // handle batch\n      map(payload, self._handleAsync.bind(self), cb);\n    } else {\n      // handle single\n      self._handleAsync(payload, cb);\n    }\n  });\n}; // private\n\n\nWeb3ProviderEngine.prototype._handleAsync = function (payload, finished) {\n  var self = this;\n  var currentProvider = -1;\n  var result = null;\n  var error = null;\n  var stack = [];\n  next();\n\n  function next(after) {\n    currentProvider += 1;\n    stack.unshift(after); // Bubbled down as far as we could go, and the request wasn't\n    // handled. Return an error.\n\n    if (currentProvider >= self._providers.length) {\n      end(new Error('Request for method \"' + payload.method + '\" not handled by any subprovider. Please check your subprovider configuration to ensure this method is handled.'));\n    } else {\n      try {\n        var provider = self._providers[currentProvider];\n        provider.handleRequest(payload, next, end);\n      } catch (e) {\n        end(e);\n      }\n    }\n  }\n\n  function end(_error, _result) {\n    error = _error;\n    result = _result;\n    eachSeries(stack, function (fn, callback) {\n      if (fn) {\n        fn(error, result, callback);\n      } else {\n        callback();\n      }\n    }, function () {\n      // console.log('COMPLETED:', payload)\n      // console.log('RESULT: ', result)\n      var resultObj = {\n        id: payload.id,\n        jsonrpc: payload.jsonrpc,\n        result: result\n      };\n\n      if (error != null) {\n        resultObj.error = {\n          message: error.stack || error.message || error,\n          code: -32000 // respond with both error formats\n\n        };\n        finished(error, resultObj);\n      } else {\n        finished(null, resultObj);\n      }\n    });\n  }\n}; //\n// from remote-data\n//\n\n\nWeb3ProviderEngine.prototype._setCurrentBlock = function (block) {\n  const self = this;\n  self.currentBlock = block;\n  self.emit('block', block);\n}; // util\n\n\nfunction toBufferBlock(jsonBlock) {\n  return {\n    number: ethUtil.toBuffer(jsonBlock.number),\n    hash: ethUtil.toBuffer(jsonBlock.hash),\n    parentHash: ethUtil.toBuffer(jsonBlock.parentHash),\n    nonce: ethUtil.toBuffer(jsonBlock.nonce),\n    sha3Uncles: ethUtil.toBuffer(jsonBlock.sha3Uncles),\n    logsBloom: ethUtil.toBuffer(jsonBlock.logsBloom),\n    transactionsRoot: ethUtil.toBuffer(jsonBlock.transactionsRoot),\n    stateRoot: ethUtil.toBuffer(jsonBlock.stateRoot),\n    receiptsRoot: ethUtil.toBuffer(jsonBlock.receiptRoot || jsonBlock.receiptsRoot),\n    miner: ethUtil.toBuffer(jsonBlock.miner),\n    difficulty: ethUtil.toBuffer(jsonBlock.difficulty),\n    totalDifficulty: ethUtil.toBuffer(jsonBlock.totalDifficulty),\n    size: ethUtil.toBuffer(jsonBlock.size),\n    extraData: ethUtil.toBuffer(jsonBlock.extraData),\n    gasLimit: ethUtil.toBuffer(jsonBlock.gasLimit),\n    gasUsed: ethUtil.toBuffer(jsonBlock.gasUsed),\n    timestamp: ethUtil.toBuffer(jsonBlock.timestamp),\n    transactions: jsonBlock.transactions\n  };\n}","map":null,"metadata":{},"sourceType":"script"}