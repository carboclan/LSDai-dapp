{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _ = require(\"lodash\");\n\nvar signature_parser_1 = require(\"./utils/signature_parser\");\n\nvar address_1 = require(\"./evm_data_types/address\");\n\nvar array_1 = require(\"./evm_data_types/array\");\n\nvar bool_1 = require(\"./evm_data_types/bool\");\n\nvar dynamic_bytes_1 = require(\"./evm_data_types/dynamic_bytes\");\n\nvar int_1 = require(\"./evm_data_types/int\");\n\nvar method_1 = require(\"./evm_data_types/method\");\n\nvar pointer_1 = require(\"./evm_data_types/pointer\");\n\nvar static_bytes_1 = require(\"./evm_data_types/static_bytes\");\n\nvar string_1 = require(\"./evm_data_types/string\");\n\nvar tuple_1 = require(\"./evm_data_types/tuple\");\n\nvar uint_1 = require(\"./evm_data_types/uint\");\n\nvar Address =\n/** @class */\nfunction (_super) {\n  __extends(Address, _super);\n\n  function Address(dataItem) {\n    return _super.call(this, dataItem, EvmDataTypeFactory.getInstance()) || this;\n  }\n\n  return Address;\n}(address_1.AddressDataType);\n\nexports.Address = Address;\n\nvar Bool =\n/** @class */\nfunction (_super) {\n  __extends(Bool, _super);\n\n  function Bool(dataItem) {\n    return _super.call(this, dataItem, EvmDataTypeFactory.getInstance()) || this;\n  }\n\n  return Bool;\n}(bool_1.BoolDataType);\n\nexports.Bool = Bool;\n\nvar Int =\n/** @class */\nfunction (_super) {\n  __extends(Int, _super);\n\n  function Int(dataItem) {\n    return _super.call(this, dataItem, EvmDataTypeFactory.getInstance()) || this;\n  }\n\n  return Int;\n}(int_1.IntDataType);\n\nexports.Int = Int;\n\nvar UInt =\n/** @class */\nfunction (_super) {\n  __extends(UInt, _super);\n\n  function UInt(dataItem) {\n    return _super.call(this, dataItem, EvmDataTypeFactory.getInstance()) || this;\n  }\n\n  return UInt;\n}(uint_1.UIntDataType);\n\nexports.UInt = UInt;\n\nvar StaticBytes =\n/** @class */\nfunction (_super) {\n  __extends(StaticBytes, _super);\n\n  function StaticBytes(dataItem) {\n    return _super.call(this, dataItem, EvmDataTypeFactory.getInstance()) || this;\n  }\n\n  return StaticBytes;\n}(static_bytes_1.StaticBytesDataType);\n\nexports.StaticBytes = StaticBytes;\n\nvar DynamicBytes =\n/** @class */\nfunction (_super) {\n  __extends(DynamicBytes, _super);\n\n  function DynamicBytes(dataItem) {\n    return _super.call(this, dataItem, EvmDataTypeFactory.getInstance()) || this;\n  }\n\n  return DynamicBytes;\n}(dynamic_bytes_1.DynamicBytesDataType);\n\nexports.DynamicBytes = DynamicBytes;\n\nvar String =\n/** @class */\nfunction (_super) {\n  __extends(String, _super);\n\n  function String(dataItem) {\n    return _super.call(this, dataItem, EvmDataTypeFactory.getInstance()) || this;\n  }\n\n  return String;\n}(string_1.StringDataType);\n\nexports.String = String;\n\nvar Pointer =\n/** @class */\nfunction (_super) {\n  __extends(Pointer, _super);\n\n  function Pointer(destDataType, parentDataType) {\n    return _super.call(this, destDataType, parentDataType, EvmDataTypeFactory.getInstance()) || this;\n  }\n\n  return Pointer;\n}(pointer_1.PointerDataType);\n\nexports.Pointer = Pointer;\n\nvar Tuple =\n/** @class */\nfunction (_super) {\n  __extends(Tuple, _super);\n\n  function Tuple(dataItem) {\n    return _super.call(this, dataItem, EvmDataTypeFactory.getInstance()) || this;\n  }\n\n  return Tuple;\n}(tuple_1.TupleDataType);\n\nexports.Tuple = Tuple;\n\nvar Array =\n/** @class */\nfunction (_super) {\n  __extends(Array, _super);\n\n  function Array(dataItem) {\n    return _super.call(this, dataItem, EvmDataTypeFactory.getInstance()) || this;\n  }\n\n  return Array;\n}(array_1.ArrayDataType);\n\nexports.Array = Array;\n\nvar Method =\n/** @class */\nfunction (_super) {\n  __extends(Method, _super);\n\n  function Method(abi) {\n    return _super.call(this, abi, EvmDataTypeFactory.getInstance()) || this;\n  }\n\n  return Method;\n}(method_1.MethodDataType);\n\nexports.Method = Method;\n/* tslint:disable no-construct */\n\nvar EvmDataTypeFactory =\n/** @class */\nfunction () {\n  /* tslint:enable prefer-function-over-method */\n  function EvmDataTypeFactory() {}\n\n  EvmDataTypeFactory.getInstance = function () {\n    if (!EvmDataTypeFactory._instance) {\n      EvmDataTypeFactory._instance = new EvmDataTypeFactory();\n    }\n\n    return EvmDataTypeFactory._instance;\n  };\n  /* tslint:disable prefer-function-over-method */\n\n\n  EvmDataTypeFactory.prototype.create = function (dataItem, parentDataType) {\n    // Create data type\n    var dataType;\n\n    if (Array.matchType(dataItem.type)) {\n      dataType = new Array(dataItem);\n    } else if (Address.matchType(dataItem.type)) {\n      dataType = new Address(dataItem);\n    } else if (Bool.matchType(dataItem.type)) {\n      dataType = new Bool(dataItem);\n    } else if (Int.matchType(dataItem.type)) {\n      dataType = new Int(dataItem);\n    } else if (UInt.matchType(dataItem.type)) {\n      dataType = new UInt(dataItem);\n    } else if (StaticBytes.matchType(dataItem.type)) {\n      dataType = new StaticBytes(dataItem);\n    } else if (Tuple.matchType(dataItem.type)) {\n      dataType = new Tuple(dataItem);\n    } else if (DynamicBytes.matchType(dataItem.type)) {\n      dataType = new DynamicBytes(dataItem);\n    } else if (String.matchType(dataItem.type)) {\n      dataType = new String(dataItem);\n    } // @TODO: DataTypeement Fixed/UFixed types\n\n\n    if (dataType === undefined) {\n      throw new Error(\"Unrecognized data type: '\" + dataItem.type + \"'\");\n    } else if (parentDataType !== undefined && !dataType.isStatic()) {\n      var pointerToDataType = new Pointer(dataType, parentDataType);\n      return pointerToDataType;\n    }\n\n    return dataType;\n  };\n\n  return EvmDataTypeFactory;\n}();\n\nexports.EvmDataTypeFactory = EvmDataTypeFactory;\n/**\n * Convenience function for creating a DataType from different inputs.\n * @param input A single or set of DataItem or a signature for an EVM data type.\n * @return DataType corresponding to input.\n */\n\nfunction create(input) {\n  var dataItem = consolidateDataItemsIntoSingle(input);\n  var dataType = EvmDataTypeFactory.getInstance().create(dataItem);\n  return dataType;\n}\n\nexports.create = create;\n/**\n * Convenience function to aggregate a single input or a set of inputs into a single DataItem.\n * An array of data items is grouped into a single tuple.\n * @param input A single data item; a set of data items; a signature.\n * @return A single data item corresponding to input.\n */\n\nfunction consolidateDataItemsIntoSingle(input) {\n  var dataItem;\n\n  if (_.isArray(input)) {\n    var dataItems = input;\n    dataItem = {\n      name: '',\n      type: 'tuple',\n      components: dataItems\n    };\n  } else {\n    dataItem = _.isString(input) ? signature_parser_1.generateDataItemFromSignature(input) : input;\n  }\n\n  return dataItem;\n}\n/**\n * Convenience function for creating a Method encoder from different inputs.\n * @param methodName name of method.\n * @param input A single data item; a set of data items; a signature; or an array of signatures (optional).\n * @param output A single data item; a set of data items; a signature; or an array of signatures (optional).\n * @return Method corresponding to input.\n */\n\n\nfunction createMethod(methodName, input, output) {\n  var methodInput = input === undefined ? [] : consolidateDataItemsIntoArray(input);\n  var methodOutput = output === undefined ? [] : consolidateDataItemsIntoArray(output);\n  var methodAbi = {\n    name: methodName,\n    inputs: methodInput,\n    outputs: methodOutput,\n    type: 'function',\n    // default fields not used by ABI\n    constant: false,\n    payable: false,\n    stateMutability: 'nonpayable'\n  };\n  var dataType = new Method(methodAbi);\n  return dataType;\n}\n\nexports.createMethod = createMethod;\n/**\n * Convenience function that aggregates a single input or a set of inputs into an array of DataItems.\n * @param input A single data item; a set of data items; a signature; or an array of signatures.\n * @return Array of data items corresponding to input.\n */\n\nfunction consolidateDataItemsIntoArray(input) {\n  var dataItems;\n\n  if (_.isArray(input) && _.isEmpty(input)) {\n    dataItems = [];\n  } else if (_.isArray(input) && _.isString(input[0])) {\n    dataItems = [];\n\n    _.each(input, function (signature) {\n      var dataItem = signature_parser_1.generateDataItemFromSignature(signature);\n      dataItems.push(dataItem);\n    });\n  } else if (_.isArray(input)) {\n    dataItems = input;\n  } else if (typeof input === 'string') {\n    var dataItem = signature_parser_1.generateDataItemFromSignature(input);\n    dataItems = [dataItem];\n  } else {\n    dataItems = [input];\n  }\n\n  return dataItems;\n}\n/* tslint:enable no-construct */","map":null,"metadata":{},"sourceType":"script"}